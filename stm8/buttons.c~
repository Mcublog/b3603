
#include "uart.h"
#include "stm8s.h"

// PC_CR1 = (1<<7); // For the button
// PD_CR1 = (1<<1) | (1<<4); // For the button



void read_buttons(void)
{
    uint8_t dominant_keys_pressed=0;
    uint8_t secondary_keys_pressed=0;
    uint8_t button=0;	//value
    static uint8_t button_previous=0;
    
    uint8_t i;

    // PD1    
    if( (PD_IDR & (1<<1)) == 0) {
        dominant_keys_pressed=1;
        button=2;		//DOWN
        
    }

    // PC7
    if( (PC_IDR & (1<<7)) ==0) {
        dominant_keys_pressed=1;
        button=1;	// SET
    }
    
    if(!dominant_keys_pressed) {
        //only possible to scan for secondary keys when dominant keys are not pressed. timing wise this is not fully monkey proof, but will work.
        
        // set PD1 to output mode
        PD_ODR &= ~(1<<1);		// Output value... ~(1<<1) == 1111 1101 set PD1 output to 0
        PD_DDR |= 1<<1;			// set PD1 to output (set to 1)
        PD_CR1 |= 1<<1;			// Push Pull (set to 1)
        //PD_CR2 &= ~(1<<1);		// disable interrupts
        //PD_CR2 |= 1<<1;			// 10 Mhz
        
        // read PC7
        if( (PC_IDR & (1<<7)) ==0) {
            secondary_keys_pressed=1;
            button=4;	// OK
            //uart_write_str("OK\r\n");
            }

        // Restore to inputs
        //PD_OD |= ~(1<<1);             // ~(1<<1) == 1111 1101 set PD1 output to 0
        PD_DDR &= ~(1<<1);              // set PD1 to input (set to 0)
        PD_CR1 |= 1<<1;                 // Set PD1 to Input/pullup (set to 1)
        
        // 30 with uint_8_t or 10 wiht long 
        for(i=0;i<30;i++)__asm__("nop\n");	// wait for slow recovery/raise on pull-up, may reduced to maybe 10, but gets more sesetive to erros


        // set PC7 to output mode
        PC_ODR &= ~(1<<7);		// Output value... ~(1<<1) == 0111 1111 set PC7 output to 0
        PC_DDR |= 1<<7;			// set PC7 to output (set to 1)
        PC_CR1 |= 1<<7;			// Push Pull (set to 1)
        //return;
        //PC_CR2 &= ~(1<<7);		// disable interrupts
        //PC_CR2 |= 1<<7;			// 10 Mhz
        
        // PD1    
        if( (PD_IDR & (1<<1)) == 0) {
            secondary_keys_pressed=1;
            button=3;	// UP
            //uart_write_str("U\r\n");
        
            }
        //for(i=0;i++;i<20000)(PD_IDR &1);

        // Restore to inputs
        //PD_OD |= ~(1<<1);               // ~(1<<1) == 1111 1101 set PC7 output to 0
        PC_DDR &= ~(1<<7);                 // set PC7 to input (set to 0)
        PC_CR1 |= 1<<7;                 // set PC7 to Input/pullup (set to 1)

        // do not return into this function too fast, or else you may need:
        // for(i=0;i<10;i++)__asm__("nop\n");	// wait for slow recovery/raise on pull-up, may reduced to maybe 10, but gets more sesetive to erros

    }


// only trigger at first key press sense, ignore rest until next key is pressed (with small pause to detet no keys pressed situation)
if(button_previous==0) {
    // only react on first key event
    if (dominant_keys_pressed |secondary_keys_pressed ) {
        uart_write_str("Button pressed: ");
        uart_write_int(button);
        uart_write_str("\r\n");
    }
}

//
button_previous=button;
}

